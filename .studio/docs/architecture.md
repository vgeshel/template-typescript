# Architecture

## Architectural Patterns

### Type-Safe Full-Stack Architecture

The template uses end-to-end type safety from database to browser:

```
PostgreSQL Schema
  ↓ (kysely codegen)
Database Types (src/server/db-types.ts)
  ↓
tRPC Procedures (src/server/trpc.ts)
  ↓ (type inference)
tRPC Client (src/lib/trpc.ts)
  ↓
React Components (app/)
```

Types flow unidirectionally from the database schema through the API layer to the client. No manual type definitions are required at any layer.

### Test-Driven Development (TDD)

All code changes follow the TDD cycle:

1. Write a failing test that defines expected behavior
2. Run the test to verify it fails
3. Write minimal code to make the test pass
4. Refactor while keeping tests green
5. Repeat

The 100% coverage requirement enforced by pre-commit hooks ensures this discipline is maintained.

### Client-Server Communication

The template uses tRPC for type-safe client-server communication:

- **Server:** tRPC procedures defined in `src/server/trpc.ts` with Zod input/output schemas
- **Transport:** HTTP POST to `/api/trpc` with SuperJSON serialization
- **Client:** React hooks generated by `@trpc/react-query` in components

This eliminates the need for OpenAPI specs, GraphQL schemas, or manual API client code.

### Error Boundaries

Errors are handled at multiple layers:

- **Validation Layer:** Zod schemas validate all external input and throw on invalid data
- **Application Layer:** tRPC procedures catch domain errors and return structured error responses
- **Client Layer:** React Query provides error states for UI error handling

No errors should reach the user as raw exceptions. All errors are typed and handled explicitly.

## Technology Choices

### Bun Runtime

**Choice:** Use Bun instead of Node.js as the JavaScript runtime.

**Rationale:**
- 2-3x faster startup time than Node.js
- Built-in test runner eliminates Jest/Mocha dependencies
- Native TypeScript support without transpilation step
- Drop-in replacement for Node.js with better performance

**Trade-offs:**
- Smaller ecosystem than Node.js
- Newer project with potential stability concerns
- Some Node.js-specific packages may not work

**Decision:** Accept trade-offs for better developer experience in new projects. Teams requiring Node.js compatibility can swap runtimes with minimal changes.

### Next.js App Router

**Choice:** Use Next.js 16 App Router instead of Pages Router.

**Rationale:**
- Server Components reduce client-side JavaScript bundle size
- Streaming and Suspense improve perceived performance
- Unified data fetching model simplifies architecture
- Future direction of Next.js framework

**Trade-offs:**
- Less ecosystem maturity than Pages Router
- Some libraries don't support Server Components yet
- Steeper learning curve for developers familiar with Pages Router

**Decision:** Adopt modern architecture for new projects despite ecosystem gaps.

### tRPC Over REST or GraphQL

**Choice:** Use tRPC for API layer instead of REST, GraphQL, or gRPC.

**Rationale:**
- Full type safety with zero code generation
- Simpler than GraphQL for most use cases
- Better DX than manually maintaining OpenAPI specs
- Built-in React Query integration

**Trade-offs:**
- Requires TypeScript on both client and server
- Not suitable for public APIs consumed by third parties
- Less tooling than REST or GraphQL

**Decision:** Prioritize internal type safety over external API compatibility. Add REST endpoints if third-party integration is needed.

### Vitest Over Jest

**Choice:** Use Vitest as the test runner instead of Jest.

**Rationale:**
- Faster test execution than Jest (powered by Vite)
- Native ESM support without configuration
- Compatible with Jest API (easy migration)
- Better TypeScript integration

**Trade-offs:**
- Smaller community than Jest
- Some Jest plugins may not be compatible

**Decision:** Performance and DX improvements outweigh ecosystem concerns.

### Zod Over Other Validation Libraries

**Choice:** Use Zod for runtime validation instead of Yup, Joi, or io-ts.

**Rationale:**
- Type inference eliminates duplicate type definitions
- Composable schemas with `.pick()`, `.omit()`, `.extend()`
- Native TypeScript support without adapters
- Excellent error messages

**Trade-offs:**
- Larger bundle size than some alternatives
- Less mature than Joi

**Decision:** Type inference benefit eliminates entire class of type drift bugs.

### Pino Over Winston or Bunyan

**Choice:** Use Pino for structured logging.

**Rationale:**
- Fastest JSON logger for Node.js
- Structured logging by default (no string concatenation)
- Child loggers for request-scoped context
- Separate formatting from logging (use pino-pretty for dev)

**Trade-offs:**
- Less featureful than Winston
- Requires external transports for advanced routing

**Decision:** Performance and simplicity preferred over advanced features.

## Code Organization

### Directory Structure

```
├── .claude/                 # AI assistant configuration (skip in analysis)
├── .husky/                  # Git hooks
│   └── pre-commit          # Quality gates
├── .studio/                # Living documentation
│   └── docs/               # Architecture docs
├── app/                    # Next.js App Router
│   ├── api/trpc/          # tRPC HTTP handler
│   ├── layout.tsx         # Root layout with providers
│   ├── page.tsx           # Home page
│   └── globals.css        # Tailwind CSS
├── migrations/            # Kysely database migrations (create as needed)
├── scripts/               # Build and maintenance scripts
│   ├── check-lint-exceptions.ts
│   └── check-coverage-thresholds.ts
├── src/
│   ├── components/        # Shared React components
│   │   └── Providers.tsx  # Client-side providers
│   ├── lib/               # Shared utilities
│   │   ├── logger.ts      # Pino logger instance
│   │   ├── providers.tsx  # tRPC + React Query provider
│   │   └── trpc.ts        # tRPC client
│   ├── server/            # Server-only code
│   │   ├── db.ts          # Kysely client (commented out)
│   │   ├── db-types.ts    # Generated types (create when using DB)
│   │   └── trpc.ts        # tRPC router
│   └── test/              # Test utilities (create as needed)
├── eslint.config.mjs      # ESLint flat config
├── next.config.ts         # Next.js configuration
├── package.json           # Dependencies and scripts
├── tsconfig.json          # TypeScript configuration
└── vitest.config.ts       # Test configuration
```

### Key Directories and Their Responsibilities

**`app/`** — Next.js App Router pages and API routes. Contains UI components and routing logic. Server Components by default.

**`src/server/`** — Server-only code that never ships to the browser. Database clients, business logic, and tRPC procedures live here.

**`src/lib/`** — Shared utilities used by both client and server. Client-side tRPC configuration and providers.

**`src/components/`** — Reusable React components. Client Components that can be imported across pages.

**`scripts/`** — Maintenance scripts that run during development or CI/CD. Pre-commit hook logic lives here.

**`migrations/`** — Database schema migrations in chronological order (create when using database features).

## Security Model

### Input Validation

All external input must be validated with Zod schemas:

- **User Input:** All tRPC procedure inputs use `.input(z.object({...}))`
- **Environment Variables:** Parse with Zod schemas, never use `process.env` directly
- **API Responses:** Validate third-party API responses with Zod before using

No external data should be trusted. Type casts (`as`) are banned because they bypass validation.

### Type Safety as Security

TypeScript strict mode prevents entire classes of vulnerabilities:

- **Injection Attacks:** Kysely's query builder prevents SQL injection through parameterization
- **Type Confusion:** No `any` types means no accidental type mismatches
- **Null Pointer Errors:** Strict null checks catch undefined access at compile time

### Dependency Security

- **Automated Updates:** Use Dependabot or Renovate to keep dependencies current
- **Pre-commit Hooks:** Prevent committing secrets or sensitive data
- **Minimal Dependencies:** Fewer dependencies = smaller attack surface

## Performance Considerations

### Server-Side Rendering

Next.js App Router uses Server Components by default:

- HTML generated on server reduces client-side JavaScript
- Data fetching happens on server, closer to database
- Streaming and Suspense improve perceived performance

Use `'use client'` directive only when components need client-side state or browser APIs.

### Bundle Size Optimization

- **SuperJSON:** Efficient serialization reduces payload size vs. JSON
- **Tree Shaking:** ESM imports enable dead code elimination
- **Code Splitting:** Next.js automatically splits routes into separate bundles

### Database Query Optimization

- **Type-Safe Queries:** Kysely provides compile-time query validation
- **Connection Pooling:** Use connection pool for PostgreSQL (configure in `db.ts`)
- **Transactions:** Wrap multi-query operations in transactions for consistency

### Test Performance

- **No File Parallelism:** Required due to Bun limitations with database connections
- **Fast Unit Tests:** Vitest executes tests in milliseconds
- **Minimal Mocking:** Testing real implementations reduces test maintenance

The coverage report is generated during pre-commit hooks to catch untested code immediately.